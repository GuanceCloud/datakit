// Unless explicitly stated otherwise all files in this repository are licensed
// under the MIT License.
// This product includes software developed at Guance Cloud (https://www.guance.com/).
// Copyright 2021-present Guance, Inc.

package config

import (
	"fmt"
	"io/ioutil"
	"path/filepath"

	"gitlab.jiagouyun.com/cloudcare-tools/datakit/internal/datakit"
	"gitlab.jiagouyun.com/cloudcare-tools/datakit/internal/io"
	"gitlab.jiagouyun.com/cloudcare-tools/datakit/internal/pipeline"
	"gitlab.jiagouyun.com/cloudcare-tools/datakit/internal/plugins/inputs"
)

const (
	pipelineWarning = `
#------------------------------------   W A R N   -------------------------------------
# This file generated by Datakit. Do not edit.
#--------------------------------------------------------------------------------------
`
)

func initPluginPipeline(ipts map[string]inputs.Creator) error {
	scriptMap, err := getScriptMap(ipts)
	if err != nil {
		l.Errorf(err.Error())
		return err
	}

	for name, script := range scriptMap {
		plPath := filepath.Join(datakit.PipelineDir, name)
		if err := ioutil.WriteFile(plPath, []byte(script), datakit.ConfPerm); err != nil {
			l.Errorf("failed to create pipeline script for %s: %s", name, err.Error())
			return err
		}
	}

	if err := pipeline.InitPipeline(Cfg.Pipeline, io.PLAggFeed, datakit.GlobalHostTags(), datakit.InstallDir); err != nil {
		return err
	}

	return nil
}

func getScriptMap(ipts map[string]inputs.Creator) (map[string]string, error) {
	scriptMap := map[string]string{}
	for _, c := range ipts {
		if v, ok := c().(inputs.PipelineInput); ok {
			scripts := v.PipelineConfig()
			for n, script := range scripts {
				// Ignore empty pipeline script.
				if script == "" {
					continue
				}
				name := n + ".p"
				if _, has := scriptMap[name]; has {
					return nil, fmt.Errorf("duplicated pipeline script name: %s", name)
				}
				scriptMap[name] = pipelineWarning + script
			}
		}
	}
	return scriptMap, nil
}
